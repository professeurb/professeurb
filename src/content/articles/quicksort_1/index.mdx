---
title:  "Le Problème avec QuickSort, partie 1"
subtitle: Où l'on explore quelques éléments délicats concernant QuickSort…
tags: ['Tris', 'IPT Spé']
---

import Figure from './figure.jsx'
import Center from 'components/Center.js'

L'algorithme de [tri rapide](https://fr.wikipedia.org/wiki/Tri_rapide), ou [Quicksort](https://en.wikipedia.org/wiki/Quicksort), figure au programme d'_Informatique pour tous_, le cours commun d'informatique des classes préparatoires scientifiques en deuxième année. Or, pour ce cours, le langage de référence est Python… et c'est vraiment difficile de bien montrer à quel point cet algorithme est intéressant.

# Présentation du problème

L'idée de base de Quicksort est très simple&nbsp;: pour trier une liste `py§l`, il suffit de prendre un élément `py§p` de la liste (que l'on appelle le **pivot**), sélectionner les éléments de `py§l` plus petits que `py§p` et les trier, sélectionner ceux qui sont plus grands et les trier… et tout remettre dans l'ordre.

Ainsi, pour trier la liste `py§l = [3, 7, 4, 5, 1, 2, 6, 8, 9, 0]`, on définit
le pivot comme le premier élément de la liste&nbsp;: `py§p = 3` et on sépare le reste en deux sous-listes&nbsp;:

```python
plus_petit = [1, 2, 0]
plus_grand = [7, 4, 5, 6, 8, 9]
```

Ensuite, on trie `py§plus_petit` et `py§plus_grand` et on retourne la liste
```python
plus_petit_trie + [pivot] + plus_grand_trie
```
Comment fait-on pour trier les sous-listes&nbsp;? En rappelant l'algorithme, sachant qu'une liste de longueur&nbsp;`py§1` est déjà triée.

Cela donne l'algorithme suivant&nbsp;:
```python
def pseudo_quicksort(l):
    if len(l) <= 1:
        return l # la liste est déjà triée
    pivot = l[0]
    plus_petit = []
    plus_grand = []
    for e in l[1:]:
        if e <= pivot:
            plus_petit.append(e)
        else:
            plus_grand.append(e)
    return pseudo_quicksort(plus_petit) \\
        + [pivot] + pseudo_quicksort(plus_grand)
```

Quel est le problème&nbsp;? Cet algorithme est correct, il trie bien une liste, est plutôt rapide et respecte l'idée derrière Quicksort. Mais c'est une version très naïve et dénaturée de Quicksort. On a le «&nbsp;_sort_&nbsp;», mais pas vraiment le «&nbsp;_quick_&nbsp;». En particulier, cette fonction passe son temps à dupliquer des données, à créer de nouvelles listes, etc., ce que ne fait pas le _véritable_ algorithme Quicksort.

Au contraire, le «&nbsp;vrai&nbsp;» Quicksort effectue un tri _en place_ (c.à.d. il modifie le tableau plutôt que d'en créer un nouveau) et la seule mémoire supplémentaire qu'il utilise est pour la pile d'appel lors de la récursion (de taille logarithmique par rapport à la taille de liste, donc quasiment négligeable). Et il est vraiment très rapide.

Dans la version originale de Hoare, on a deux pointeurs qui se déplacent, l'un `py§i` de gauche à droite en s'assurant que les éléments le précédant sont plus petits que le pivot, et un autre `py§j` de droite à gauche avec tous les éléments le suivant strictement plus grands que le pivot&nbsp;:

<Center>
<Figure />
</Center>

Quel est le problème, donc&nbsp;? C'est qu'il est assez difficile de montrer que la _bonne_ version est vraiment meilleure que la _mauvaise_ en Python, puisque que le code de la fonction `py§pseudo_quicksort` ci-dessus est plus rapide que le code _propre_ (et très commenté, peut-être un peu trop, mais les invariants de boucles permettent de vérifier facilement la correction de l'implémentation) de Quicksort&nbsp;:

```python
def quicksort(l):
    def aux(debut, fin) :
        # Si debut <= fin + 1, la liste est de longueur au plus 1,
        # elle est déjà triée.
        if fin <= debut + 1:
            return
        # On choisit le pivot,
        pivot = l[debut]
        # Puis on va partager le reste de la liste
        # par rapport à ce pivot.
        i = debut + 1
        j = fin - 1
        while True:
            # Invariant de boucle
            # 1. debut < i, j < fin et i <= j + 1
            # 2. si debut < k < i alors l[k] <= pivot
            # 3. si j < k < fin alors pivot <= l[k]
            while i <= j and l[i] <= pivot:
                i += 1
            # en sortie de boucle, on a soit
            # 1. i == j + 1
            # 2. soit i <= j et l[i] > pivot
            while i <= j and l[j] > pivot:
                j -= 1
            # de même, en sortie de boucle, on a soit
            # 1. i == j + 1
            # 2. soit i <= j et l[j] <= pivot
            # En conclusion, deux cas sont possibles ici :
            # 1. i == j + 1
            # 2. i <= j et l[j] <= pivot < l[i]
            # Dans le premier cas, on a fini de trier
            if (i > j):
                break
            # Sinon, on a donc l[j] <= pivot < l[i]
            #   et donc i < j
            # On échange les deux éléments :
            l[i], l[j] = l[j], l[i]
            # et on continue
            i += 1
            j -= 1
        # On a maintenant
        # 1. i == j + 1
        # 2. debut < k <= j => l[k] <= pivot
        # 3. i <= k < fin => l[k] > pivot
        # On mets le pivot à sa place
        l[debut], l[j] = l[j], l[debut]
        # et on trie les deux côtés séparément.
        aux(debut, j)
        aux(i, fin)
    aux(0, len(l))
```

# Vérification du problème

Pour vérifier que la _mauvaise_ version est plus rapide que la _bonne_, comparons les temps avec la fonction `py§timeit`.

Pour cela, crééons tout d'abord la liste à trier, constituée de `py§1000` entiers choisis aléatoirement entre `py§0` et `py§1000`.

```python
>>> import random
>>> l = [random.randint(0, 1000) for i in range(1000)]
```

Nous allons maintenant chronométrer le temps mis pour faire 100 fois le tri de `py§l`.

```python
>>> import timeit
>>> timeit.timeit("pseudo_quicksort(ll)", \\
      setup="from __main__ import pseudo_quicksort, l; ll = l[:]", \\
      number=100)
0.16471761098364368
>>> timeit.timeit("quicksort(ll)", \\
      setup="from __main__ import quicksort, l; ll = l[:]", \\
      number=100)
3.079240838007536
```

Clairement, `py§pseudo-quicksort` est plus rapide, il mets 164&nbsp;ms à s'exécuter alors que `py§quicksort` mets plus de 3 secondes.

La raison est la suivante&nbsp;: la boucle sur la liste (`py§for e in l[1:]`) et les concaténations de listes sont très rapides, elles sont exécutées directement à partir de code pré-compilé et optimisé. À l'inverse, dans `py§quicksort`, tout est fait à la main.

# Un autre comparatif

Pour comparer les temps d'exécutions avec une implémentation plus sérieuse, nous allons refaire la même expérience en langage C++. Voici tout d'abord le code de `py§pseudo_quicksort`&nbsp;:
```c++
std::vector<int> pseudo_quicksort(std::vector<int> l) {
  if (l.size() <= 1) {
    return l;
  }
  int pivot = l[0];
  std::vector<int> plus_petit, plus_grand;
  for (auto it = l.begin() + 1 ; it != l.end(); ++it) {
    if (*it <= pivot) {
      plus_petit.push_back(*it);
    } else {
      plus_grand.push_back(*it);
    }
  }
  // On trie plus_petit et plus_grand
  std::vector<int> r = pseudo_quicksort(plus_petit);
  std::vector<int> r2 = pseudo_quicksort(plus_grand);
  // On reconstruit le résultat final...
  r.push_back(pivot);
  r.insert(r.end(), r2.begin(), r2.end());
  // ... avant de le renvoyer.
  return r;
}
```

Voici maintenant le code de `py§quicksort`&nbsp;:
```c++
void quicksort_aux(int l[], int debut, int fin) {
  if (fin <= debut + 1)
    return;
  int pivot = l[debut];
  int i = debut + 1, j = fin - 1;
  while (true) {
    while (i <= j && l[i] <= pivot) {
      i += 1;
    }
    while (i <= j && l[j] > pivot) {
      j -= 1;
    }
    if (i > j) {
      break;
    }
    int tmp = l[i];
    l[i] = l[j];
    l[j] = tmp;
    i += 1;
    j -= 1;
  }
  int tmp = l[debut];
  l[debut] = l[j];
  l[j] = tmp;
  quicksort_aux(l, debut, j);
  quicksort_aux(l, i, fin);
}

void quicksort(std::vector<int> l) {
  quicksort_aux(l.data(), 0, l.size());
}
```

Les deux sont une traduction directe du code Python précédent. En triant une liste de 1000000 entiers, j'obtiens le résultat suivant&nbsp;:
```
clock resolution: mean is 47.536 ns (10240002 iterations)

benchmarking pseudo_quicksort
collecting 100 samples, 1 iterations each, in estimated 85.2807 s
mean: 854.245 ms, lb 847.087 ms, ub 862.863 ms, ci 0.95
std dev: 39.8463 ms, lb 33.4953 ms, ub 50.2214 ms, ci 0.95
found 5 outliers among 100 samples (5%)
variance is moderately inflated by outliers

benchmarking quicksort
collecting 100 samples, 1 iterations each, in estimated 626.126 ms
mean: 6.3364 ms, lb 6.26806 ms, ub 6.42072 ms, ci 0.95
std dev: 386.494 μs, lb 322.376 μs, ub 493.992 μs, ci 0.95
found 4 outliers among 100 samples (4%)
variance is severely inflated by outliers
```

Ce que l'on peut y lire, c'est que la version `py§quicksort` mets en moyenne 6.3364&nbsp;ms alors que la version `py§pseudo_quicksort` mets quand à elle... 854.245&nbsp;ms.

Que dire de plus&nbsp;? Qu'il existe d'autres problèmes très intéressant concernant l'efficacité de Quicksort, que nous développerons dans un [prochain article](../quicksort_2).
